2. 作用域
----------------

.. _namespaces:

2.1. 命名空間 (Namespaces)
~~~~~~~~~~~~~~~~~~~~~~~~

.. tip::

    除了少數的例外，都建議使用把程式碼放在命名空間內。一個具名的命名空間應該擁有唯一的名字，其名稱可基於專案名稱，甚至是相對路徑。而在 ``.cc`` 文件內，使用匿名的命名空間是推薦的，但禁止使用 using 指示（using-directives）和內聯命名空間（inline namespaces）。

定義:

    命名空間將全域作用域細分為獨立的，具名的作用域可有效防止全域作用域的命名衝突。

優點:

    命名空間可以在大型專案內避免名稱衝突，同時又可以讓多數的程式碼有合理簡短的名稱。

    舉例來說, 兩個不同專案的全域作用域都有一個類別 ``Foo``，這樣在編譯或運行時期會造成衝突。如果每個專案將程式碼置於不同命名空間中，``project1::Foo`` 和 ``project2::Foo`` 在專案中就可以被視為不同的 symbols 而不會發生衝突。兩個類別在各自的命名空間中，也可以繼續使用 ``Foo`` 而不需要前綴命名空間。

    內聯命名空間會自動把內部的標識符放到外層作用域，比如：

    .. code-block:: c++

        namespace X {
        inline namespace Y {
        void foo();
        }
        }

    ``X::Y::foo()`` 與 ``X::foo()`` 彼此可以互換使用。內聯命名空間主要用來保持跨版本的 ABI 相容性。

缺點:

    命名空間可能造成疑惑，因為它增加了識別一個名稱所代表的意涵的難度。例如： ``Foo`` 是命名空間或是一個類別。

    內聯命名空間更是容易令人疑惑，因為它並不完全符合命名空間的定義；內聯命名空間只在大型版本控制裡會被使用到。

    在標頭檔中使用匿名命名空間容易導致違背 C++ 的唯一定義原則 (One Definition Rule (ODR))。
    
    在某些狀況中，經常會需要重複的使用完整 (fully-qualified) 的名稱來參考某些 symbols。對於多層巢狀的命名空間，這會增加許多混亂。

結論:

    根據下文將要提到的策略合理使用命名空間。記得在命名空間的結尾使用註解進行標示，例如下一節的範例程式一樣。

2.1.1. 匿名命名空間 (Unnamed Namespaces)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- 在 ``.cc`` 文件中, 可以使用匿名命名空間，甚至鼓勵使用來避免連結時期 (link time) 的命名衝突：

    .. code-block:: c++

        namespace {                             // .cc 文件中

        // 命名空間的內容無需縮進
        
        // 此函數產生出來的 symbol 保證不會和連結時期的其他 symbol 相撞。且此 symbol
        // 只能在這個 .cc 文件中被看到。
        bool UpdateInternals(Frobber* f, int newval) {
          ...
        }

        } // namespace

- 不要在 ``.h`` 文件中使用匿名命名空間。

2.1.2. 具名的命名空間
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

具名的命名空間使用方式如下：

    - 在 ``include``、`gflags <http://code.google.com/p/google-gflags/>`_ 的宣告/定義, 以及類別的前置聲明後，把整個原始碼文件剩下部分放置在命名空間內，以區別於其它命名空間：

        .. code-block:: c++

            // .h 文件
            namespace mynamespace {

            // 所有宣告都置於命名空間中
            // 注意不要使用縮進
            class MyClass {
                public:
                …
                void Foo();
            };

            } // namespace mynamespace

        .. code-block:: c++

            // .cc 文件
            namespace mynamespace {

            // 函數定義都置於命名空間中
            void MyClass::Foo() {
                …
            }

            } // namespace mynamespace

        通常的 ``.cc`` 文件包含更多，更複雜的細節，例如 flags 或 using-declarations。

        .. code-block:: c++

            #include "a.h"

            DEFINE_bool(someflag, false, "dummy flag");
            
            using ::foo::bar;

            namespace a {

            …code for a…

            } // namespace a


    - 不要在命名空間 ``std`` 內宣告任何東西，包括標準庫的類別前置聲明。在 ``std`` 命名空間宣告實體 (entities) 會導致不確定行為 (undefined behavior)。比如不可移植。要宣告標準函式庫內的實體，直接 ``include ``對應的標頭檔。

    - 最好不要使用 using-directive 來導出一個命名空間下的所有名稱。

        .. code-block:: c++

            // 禁止 —— 這會污染命名空間
            using namespace foo;
    
    - 不要在標頭檔中的一個命名空間的作用域內使用命名空間別名 (Namespace aliases)，除非該命名空間僅限於內部使用 (internal-only)。因為此操作會導致這些外部引入的東西變成此標頭檔公開的 API 的一部份。
    
        .. code-block:: c++

            // 在 .cc 文件裡可以用來縮短常使用的名稱
            namespace fbz = ::foo::bar::baz;

            // 在 .h 文件裡可以用來縮短常使用的名稱
            namespace librarian {
            namespace impl { // 內部使用，不公開於 API
            namespace sidetable = ::pipeline_diagnostics::sidetable;
            } // namespace impl

            inline void my_inline_function() {
              // 命名空間別名到一個函數或方法
              namespace fbz = ::foo::bar::baz;
              ...
            }
            }  // namespace librarian

    - 禁止用內聯命名空間

2.2. 非成員函數、靜態成員函數和全域函數
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. tip::

    使用靜態成員函數或命名空間內的非成員函數, 盡量不要用裸的全域函數.

優點:

    某些情況下, 非成員函數和靜態成員函數是非常有用的, 將非成員函數放在命名空間內可避免污染全域作用域.

缺點:

    將非成員函數和靜態成員函數作為新類的成員或許更有意義, 當它們需要訪問外部資源或具有重要的相依性關係時更是如此.

結論:

    有時, 把函數的定義同類的實例脫鉤是有益的, 甚至是必要的. 這樣的函數可以被定義成靜態成員, 或是非成員函數. 非成員函數不應相依性於外部變數, 應盡量置於某個命名空間內. 相比單純為了封裝若幹不共享任何靜態數據的靜態成員函數而創建類, 不如使用:ref:`namespaces`。

    定義在同一編譯單元的函數, 被其他編譯單元直接呼叫可能會引入不必要的耦合和連結時相依性; 靜態成員函數對此尤其敏感. 可以考慮提取到新類中, 或者將函數置於獨立庫的命名空間內.

    如果你必須定義非成員函數, 又只是在 ``.cc`` 文件中使用它, 可使用匿名:ref:`namespaces`或 ``static`` 連結關鍵字 (如 ``static int Foo() {...}``) 限定其作用域.

2.3. 區域變數
~~~~~~~~~~~~~~~~~~~~~~

.. tip::

    將函數變數盡可能置於最小作用域內, 並在變量宣告時進行初始化.

C++ 允許在函數的任何位置宣告變數. 我們提倡在盡可能小的作用域中聲明變量, 離第一次使用越近越好. 這使得程式碼瀏覽者更容易定位變量聲明的位置, 瞭解變量的類型和初始值. 特別是，應使用初始化的方式替代聲明再賦值, 比如:

    .. code-block:: c++

        int i;
        i = f(); // 壞——初始化和宣告分離
        int j = g(); // 好——初始化時宣告

        vector<int> v;
        v.push_back(1); // 用花括號初始化更好
        v.push_back(2);

        vector<int> v = {1, 2}; // 好——v 一開始就初始化


注意, GCC 可正確實現了 ``for (int i = 0; i < 10; ++i)`` (``i`` 的作用域僅限 ``for`` 循環內), 所以其他 ``for`` 循環中可以重新使用 ``i``. 在 ``if`` 和 ``while`` 等語句中的作用域宣告也是正確的, 如:

    .. code-block:: c++

        while (const char* p = strchr(str, 『/』)) str = p + 1;


    .. warning:: 如果變數是一個對象, 每次進入作用域都要呼叫其建構子, 每次退出作用域都要呼叫其解構子.

    .. code-block:: c++

        // 低效的實現
        for (int i = 0; i < 1000000; ++i) {
            Foo f;                  // 建構子和解構子分別呼叫 1000000 次!
            f.DoSomething(i);
        }

在循環作用域外面宣告這類變數要高效的多:

    .. code-block:: c++

        Foo f;                      // 建構子和解構子只呼叫 1 次
        for (int i = 0; i < 1000000; ++i) {
            f.DoSomething(i);
        }

2.4. 靜態和全域變數
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. tip::

    禁止使用 ``class`` 類型的靜態或全域變數：它們會導致難以發現的 bug 和不確定的建構和解構子呼叫順序。不過 ``constexpr`` 變量除外，畢竟它們又不涉及動態初始化或解構。

靜態生存週期的對象，即包括了全域變數，靜態變量，靜態類成員變量和函數靜態變量，都必須是原生數據類型 (POD : Plain Old Data): 即 int, char 和 float, 以及 POD 類型的指標、陣列和結構體。

靜態變數的建構子、解構子和初始化的順序在 C++ 中是不確定的，甚至隨著構建變化而變化，導致難以發現的 bug. 所以除了禁用類類型的全域變量，我們也不允許用函數返回值來初始化 POD 變量，除非該函數不涉及（比如 getenv() 或 getpid()）不涉及任何全域變量。（函數作用域裡的靜態變量除外，畢竟它的初始化順序是有明確定義的，而且只會在指令執行到它的宣告那裡才會發生。）

同理，全域和靜態變數在程式中斷時會被解構，無論所謂中斷是從 ``main()`` 返回還是對 ``exit()`` 的呼叫。析構順序正好與建構子呼叫的順序相反。但既然建構順序未定義，那麼析構順序當然也就不定了。比如，在程式結束時某靜態變量已經被析構了，但程式碼還在跑——比如其它線程——並試圖訪問它且失敗；再比如，一個靜態 string 變量也許會在一個引用了前者的其它變量析構之前被析構掉。

改善以上解構問題的辦法之一是用 ``quick_exit()`` 來代替 ``exit()`` 並中斷程式。它們的不同之處是前者不會執行任何析構，也不會執行 ``atexit()`` 所綁定的任何 handlers. 如果你想在執行 ``quick_exit()`` 來中斷時執行某 handler（比如刷新 log），你可以把它綁定到 ``_at_quick_exit()``. 如果你想在 ``exit()`` 和 ``quick_exit()`` 都用上該 handler, 都綁定上去。

綜上所述，我們只允許 POD 類型的靜態變數，即完全禁用 ``vector`` (使用 C 陣列替代) 和 ``string`` (使用 ``const char []``)。

如果你確實需要一個 ``class`` 類型的靜態或全域變數，可以考慮在 ``main()`` 函數或 ``pthread_once()`` 內初始化一個指標且永不回收。注意只能用 raw 指針，別用智慧指針，畢竟後者的解構子涉及到上文指出的不定順序問題。

.. note:: Yang.Y 譯注:

    上文提及的靜態變數泛指靜態生存週期的對象, 包括: 全域變量, 靜態變量, 靜態類成員變量, 以及函數靜態變量.

譯者 (YuleFox) 筆記
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#. ``cc`` 中的匿名命名空間可避免命名衝突, 限定作用域, 避免直接使用 ``using`` 關鍵字污染命名空間;
#. 巢狀類別符合局部使用原則, 只是不能在其他標頭檔中前置宣告, 盡量不要 ``public``;
#. 盡量不用全域函數和全域變數, 考慮作用域和命名空間限制, 盡量單獨形成編譯單元;
#. 多線程中的全域變數 (含靜態成員變量) 不要使用 ``class`` 類型 (含 STL 容器), 避免不明確行為導致的 bug.
#. 作用域的使用, 除了考慮名稱污染, 可讀性之外, 主要是為降低耦合, 提高編譯/執行效率.

譯者（acgtyrant）筆記
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#. 注意「using 指示（using-directive）」和「using 宣告（using-declaration）」的區別。
#. 匿名命名空間說白了就是文件作用域，就像 C static 宣告的作用域一樣，後者已經被 C++ 標準提倡棄用。
#. 區域變數在宣告的同時進行顯式值初始化，比起隱式初始化再賦值的兩步過程要高效，同時也貫徹了計算機體系結構重要的概念「局部性（locality）」。
#. 注意別在循環犯大量建構和解構的低級錯誤。
