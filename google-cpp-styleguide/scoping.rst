2. 作用域
----------------

.. _namespaces:

2.1. 命名空間
~~~~~~~~~~~~~~~~~~~~~~~~

.. tip::

    鼓勵在 ``.cc`` 文件內使用匿名命名空間. 使用具名的名字空間時, 其名稱可基於專案名或相對路徑. 禁止使用 using 指示（using-directive）。禁止使用內聯命名空間（inline namespace）。

定義:

    命名空間將全局作用域細分為獨立的, 具名的作用域, 可有效防止全局作用域的命名衝突.

優點:

    雖然類已經提供了（可嵌套的）命名軸線 (YuleFox 注: 將命名分割在不同類的作用域內), 命名空間在這基礎上又封裝了一層.

    舉例來說, 兩個不同專案的全局作用域都有一個類 ``Foo``, 這樣在編譯或運行時造成衝突. 如果每個項目將程式碼置於不同命名空間中, ``project1::Foo`` 和 ``project2::Foo`` 作為不同符號自然不會衝突.

    內聯命名空間會自動把內部的標識符放到外層作用域，比如：

    .. code-block:: c++

        namespace X {
        inline namespace Y {
        void foo();
        }
        }

    ``X::Y::foo()`` 與 ``X::foo()`` 彼此可代替。內聯命名空間主要用來保持跨版本的 ABI 兼容性。

缺點:

    命名空間具有迷惑性, 因為它們和類一樣提供了額外的 (可嵌套的) 命名軸線.

    命名空間很容易令人迷惑，畢竟它們不再受其聲明所在命名空間的限制。內聯命名空間只在大型版本控制裡有用。

    在標頭檔中使用匿名空間導致違背 C++ 的唯一定義原則 (One Definition Rule (ODR)).

結論:

    根據下文將要提到的策略合理使用命名空間.

2.1.1. 匿名命名空間
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- 在 ``.cc`` 文件中, 允許甚至鼓勵使用匿名命名空間, 以避免運行時的命名衝突:

    .. code-block:: c++

        namespace {                             // .cc 文件中

        // 命名空間的內容無需縮進
        enum { kUNUSED, kEOF, kERROR };         // 經常使用的符號
        bool AtEof() { return pos_ == kEOF; }   // 使用本命名空間內的符號 EOF

        } // namespace

然而, 與特定類關聯的文件作用域聲明在該類中被聲明為類型, 靜態數據成員或靜態成員函數, 而不是匿名命名空間的成員. 如上例所示, 匿名空間結束時用註解 ``// namespace`` 標識.

- 不要在 ``.h`` 文件中使用匿名命名空間.

2.1.2. 具名的命名空間
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

具名的命名空間使用方式如下:

    - 用命名空間把文件包含, `gflags <http://code.google.com/p/google-gflags/>`_ 的聲明/定義, 以及類的前置聲明以外的整個源文件封裝起來, 以區別於其它名字空間:

        .. code-block:: c++

            // .h 文件
            namespace mynamespace {

            // 所有聲明都置於命名空間中
            // 注意不要使用縮進
            class MyClass {
                public:
                …
                void Foo();
            };

            } // namespace mynamespace

        .. code-block:: c++

            // .cc 文件
            namespace mynamespace {

            // 函數定義都置於命名空間中
            void MyClass::Foo() {
                …
            }

            } // namespace mynamespace

        通常的 ``.cc`` 文件包含更多, 更複雜的細節, 比如引用其他命名空間的類等.

        .. code-block:: c++

            #include 「a.h」

            DEFINE_bool(someflag, false, 「dummy flag」);

            class C;                    // 全局命名空間中類 C 的前置聲明
            namespace a { class A; }    // a::A 的前置聲明

            namespace b {

            …code for b…                // b 中的程式碼

            } // namespace b


    - 不要在命名空間 ``std`` 內聲明任何東西, 包括標準庫的類前置聲明. 在 ``std`` 名字空間聲明實體會導致不確定的問題, 比如不可移植. 聲明標準庫下的實體, 需要包含對應的標頭檔.

    - 最好不要使用 using 指示，以保證命名空間下的所有名稱都可以正常使用.

        .. code-block:: c++

            // 禁止 —— 污染命名空間
            using namespace foo;

    - 在 ``.cc`` 文件, ``.h`` 文件的函數, 方法或類中, 可以使用 using 聲明。

        .. code-block:: c++

            // 允許: .cc 文件中
            // .h 文件的話, 必須在函數, 方法或類的內部使用
            using ::foo::bar;

    - 在 ``.cc`` 文件, ``.h`` 文件的函數, 方法或類中, 允許使用命名空間別名.

        .. code-block:: c++

            // 允許: .cc 文件中
            // .h 文件的話, 必須在函數, 方法或類的內部使用

            namespace fbz = ::foo::bar::baz;

            // 在 .h 文件裡
            namespace librarian {
            //以下別名在所有包含了該標頭檔的文件中生效。
            namespace pd_s = ::pipeline_diagnostics::sidetable;

            inline void my_inline_function() {
              // namespace alias local to a function (or method).
              namespace fbz = ::foo::bar::baz;
              ...
            }
            }  // namespace librarian

        注意在 .h 文件的別名對包含了該標頭檔的所有人可見，所以在公共標頭檔（在專案外可用）以及它們遞歸包含的其它頭文件裡，不要用別名。畢竟原則上公共 API 要盡可能地精簡。

    - 禁止用內聯命名空間

2.2. 嵌套類
~~~~~~~~~~~~~~~~~~

.. tip::

    當公有嵌套類作為接口的一部分時, 雖然可以直接將他們保持在全局作用域中, 但將嵌套類的聲明置於:ref:`namespaces`內是更好的選擇.

定義: 在一個類內部定義另一個類; 嵌套類也被稱為 *成員類 (member class)*.

    .. code-block:: c++

        class Foo {

        private:
            // Bar是嵌套在Foo中的成員類
            class Bar {
                …
            };

        };

優點:

    當嵌套 (或成員) 類只被外圍類使用時非常有用; 把它作為外圍類作用域內的成員, 而不是去污染外部作用域的同名類. 嵌套類可以在外圍類中做前置聲明, 然後在 ``.cc`` 文件中定義, 這樣避免在外圍類的聲明中定義嵌套類, 因為嵌套類的定義通常只與實現相關.

缺點:

    嵌套類只能在外圍類的內部做前置聲明. 因此, 任何使用了 ``Foo::Bar*`` 指針的標頭檔不得不包含類 ``Foo`` 的整個聲明.

結論:

    不要將嵌套類定義成公有, 除非它們是接口的一部分, 比如, 嵌套類含有某些方法的一組選項.

2.3. 非成員函數、靜態成員函數和全域函數
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. tip::

    使用靜態成員函數或命名空間內的非成員函數, 盡量不要用裸的全域函數.

優點:

    某些情況下, 非成員函數和靜態成員函數是非常有用的, 將非成員函數放在命名空間內可避免污染全局作用域.

缺點:

    將非成員函數和靜態成員函數作為新類的成員或許更有意義, 當它們需要訪問外部資源或具有重要的依賴關係時更是如此.

結論:

    有時, 把函數的定義同類的實例脫鉤是有益的, 甚至是必要的. 這樣的函數可以被定義成靜態成員, 或是非成員函數. 非成員函數不應依賴於外部變數, 應盡量置於某個命名空間內. 相比單純為了封裝若幹不共享任何靜態數據的靜態成員函數而創建類, 不如使用:ref:`namespaces`。

    定義在同一編譯單元的函數, 被其他編譯單元直接調用可能會引入不必要的耦合和鏈接時依賴; 靜態成員函數對此尤其敏感. 可以考慮提取到新類中, 或者將函數置於獨立庫的命名空間內.

    如果你必須定義非成員函數, 又只是在 ``.cc`` 文件中使用它, 可使用匿名:ref:`namespaces`或 ``static`` 鏈接關鍵字 (如 ``static int Foo() {...}``) 限定其作用域.

2.4. 區域變數
~~~~~~~~~~~~~~~~~~~~~~

.. tip::

    將函數變數盡可能置於最小作用域內, 並在變量聲明時進行初始化.

C++ 允許在函數的任何位置聲明變數. 我們提倡在盡可能小的作用域中聲明變量, 離第一次使用越近越好. 這使得程式碼瀏覽者更容易定位變量聲明的位置, 瞭解變量的類型和初始值. 特別是，應使用初始化的方式替代聲明再賦值, 比如:

    .. code-block:: c++

        int i;
        i = f(); // 壞——初始化和聲明分離
        int j = g(); // 好——初始化時聲明

        vector<int> v;
        v.push_back(1); // 用花括號初始化更好
        v.push_back(2);

        vector<int> v = {1, 2}; // 好——v 一開始就初始化


注意, GCC 可正確實現了 ``for (int i = 0; i < 10; ++i)`` (``i`` 的作用域僅限 ``for`` 循環內), 所以其他 ``for`` 循環中可以重新使用 ``i``. 在 ``if`` 和 ``while`` 等語句中的作用域聲明也是正確的, 如:

    .. code-block:: c++

        while (const char* p = strchr(str, 『/』)) str = p + 1;


    .. warning:: 如果變數是一個對像, 每次進入作用域都要調用其建構子, 每次退出作用域都要調用其解構子.

    .. code-block:: c++

        // 低效的實現
        for (int i = 0; i < 1000000; ++i) {
            Foo f;                  // 建構子和解構子分別調用 1000000 次!
            f.DoSomething(i);
        }

在循環作用域外面聲明這類變數要高效的多:

    .. code-block:: c++

        Foo f;                      // 建構子和解構子只調用 1 次
        for (int i = 0; i < 1000000; ++i) {
            f.DoSomething(i);
        }

2.5. 靜態和全域變數
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. tip::

    禁止使用 ``class`` 類型的靜態或全域變數：它們會導致難以發現的 bug 和不確定的建構和解構子調用順序。不過 ``constexpr`` 變量除外，畢竟它們又不涉及動態初始化或解構。

靜態生存週期的對象，即包括了全域變數，靜態變量，靜態類成員變量和函數靜態變量，都必須是原生數據類型 (POD : Plain Old Data): 即 int, char 和 float, 以及 POD 類型的指針、數組和結構體。

靜態變數的建構子、解構子和初始化的順序在 C++ 中是不確定的，甚至隨著構建變化而變化，導致難以發現的 bug. 所以除了禁用類類型的全局變量，我們也不允許用函數返回值來初始化 POD 變量，除非該函數不涉及（比如 getenv() 或 getpid()）不涉及任何全局變量。（函數作用域裡的靜態變量除外，畢竟它的初始化順序是有明確定義的，而且只會在指令執行到它的聲明那裡才會發生。）

同理，全局和靜態變數在程序中斷時會被解構，無論所謂中斷是從 ``main()`` 返回還是對 ``exit()`` 的調用。析構順序正好與建構子調用的順序相反。但既然建構順序未定義，那麼析構順序當然也就不定了。比如，在程序結束時某靜態變量已經被析構了，但程式碼還在跑——比如其它線程——並試圖訪問它且失敗；再比如，一個靜態 string 變量也許會在一個引用了前者的其它變量析構之前被析構掉。

改善以上解構問題的辦法之一是用 ``quick_exit()`` 來代替 ``exit()`` 並中斷程序。它們的不同之處是前者不會執行任何析構，也不會執行 ``atexit()`` 所綁定的任何 handlers. 如果您想在執行 ``quick_exit()`` 來中斷時執行某 handler（比如刷新 log），您可以把它綁定到 ``_at_quick_exit()``. 如果您想在 ``exit()`` 和 ``quick_exit()`` 都用上該 handler, 都綁定上去。

綜上所述，我們只允許 POD 類型的靜態變數，即完全禁用 ``vector`` (使用 C 數組替代) 和 ``string`` (使用 ``const char []``)。

如果您確實需要一個 ``class`` 類型的靜態或全域變數，可以考慮在 ``main()`` 函數或 ``pthread_once()`` 內初始化一個指針且永不回收。注意只能用 raw 指針，別用智能指針，畢竟後者的解構子涉及到上文指出的不定順序問題。

.. note:: Yang.Y 譯注:

    上文提及的靜態變數泛指靜態生存週期的對象, 包括: 全局變量, 靜態變量, 靜態類成員變量, 以及函數靜態變量.

譯者 (YuleFox) 筆記
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#. ``cc`` 中的匿名命名空間可避免命名衝突, 限定作用域, 避免直接使用 ``using`` 關鍵字污染命名空間;
#. 嵌套類符合局部使用原則, 只是不能在其他標頭檔中前置聲明, 盡量不要 ``public``;
#. 盡量不用全域函數和全域變數, 考慮作用域和命名空間限制, 盡量單獨形成編譯單元;
#. 多線程中的全域變數 (含靜態成員變量) 不要使用 ``class`` 類型 (含 STL 容器), 避免不明確行為導致的 bug.
#. 作用域的使用, 除了考慮名稱污染, 可讀性之外, 主要是為降低耦合, 提高編譯/執行效率.

譯者（acgtyrant）筆記
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#. 注意「using 指示（using-directive）」和「using 聲明（using-declaration）」的區別。
#. 匿名命名空間說白了就是文件作用域，就像 C static 聲明的作用域一樣，後者已經被 C++ 標準提倡棄用。
#. 區域變數在聲明的同時進行顯式值初始化，比起隱式初始化再賦值的兩步過程要高效，同時也貫徹了計算機體系結構重要的概念「局部性（locality）」。
#. 注意別在循環犯大量建構和解構的低級錯誤。
