1. 標頭檔
----------------

通常每一個 ``.cc`` 文件都有一個對應的 ``.h`` 文件. 也有一些常見例外, 如單元測試程式碼和只包含 ``main()`` 函數的 ``.cc`` 文件.

正確使用標頭檔可令程式碼在可讀性、文件大小和性能上大為改觀.

下面的規則將引導你規避使用標頭檔時的各種陷阱.

.. _self-contained headers:

1.1. Self-contained 標頭檔
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. tip::

    標頭檔應該能夠自給自足（self-contained），以 ``.h`` 結尾。至於用來插入文本的文件，說到底它們並不是標頭檔，所以應以 ``.inc`` 結尾。

所有標頭檔要能夠自給自足。換言之，使用者和重構工具不需要為特別場合而包含額外的標頭檔。詳言之，一個頭文件要有 :ref:`define-guard`，統統包含它所需要的其它頭文件，也不要求定義任何特別 symbols.

不過有一個例外，即一個文件並不是 self-contained 的，而是用來安插到程式碼某處裡，特別是要安插多次的時候。或者，文件內容實際上是其它標頭檔的特定平台（platform-specific）擴展部分。這些文件就要用 ``.inc`` 文件擴展名。

如果 ``.h`` 文件聲明了一個樣板或內聯函數，同時也在該文件加以定義。凡是有用到這些的 ``.cc`` 文件，就得統統包含該標頭檔，否則程序可能會在構建中鏈接失敗。現在不要把這些定義放到分離的 -inl.h 文件裡了（譯者註：過去該規範曾提倡把定義放到 -inl.h 裡過）。

有個例外：如果某函數樣板為所有相關模板參數顯式實例化，或本身就是某類的一個私有成員，那麼它就只能定義在實例化該模板的 ``.cc`` 文件裡。

.. _define-guard:

1.2. #define 保護
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. tip::

    所有標頭檔都應該使用 ``#define`` 防止標頭檔被多重包含, 命名格式當是: ``<PROJECT>_<PATH>_<FILE>_H_``

為保證唯一性, 標頭檔的命名應該依據所在專案源程式碼樹的全路徑. 例如, 項目 ``foo`` 中的標頭檔 ``foo/src/bar/baz.h`` 可按如下方式保護:

.. code-block:: c++

    #ifndef FOO_BAR_BAZ_H_
    #define FOO_BAR_BAZ_H_
    …
    #endif // FOO_BAR_BAZ_H_

.. _forward-declarations:

1.3. 前置聲明
~~~~~~~~~~~~~~~~~~~~~~

.. tip::

    您可以靠前置聲明來避免多餘的 ``#includes``.

定義：

	所謂「前置聲明」（forward declaration）是類，函數和樣板的純粹聲明，沒伴隨著其定義。程式碼中用到了哪些 symbols, 往往可以用其前置聲明來代替對應的 ``#includes``.

優點：

	* 多餘的 ``#includes`` 會害得編譯器花費不少時間展開更多文件，處理大量輸入。
	* 而且一旦改動標頭檔，就得重新編譯整個文件。

缺點：

	* 如果前置聲明關係到樣板，typedefs, 默認參數和 using 聲明，就很難決定它的具體樣子了。
	* 很難判斷什麼時候該用前置聲明，什麼時候該用 ``#includes``, 特別是涉及隱式轉換運算符的時候。極端情況下，用前置聲明代替 ``includes`` 甚至都會暗暗地改變程式碼的含義。
	* 前置聲明了不少來自標頭檔的 symbol 時，就會比單單 ``includes`` 一行冗長。
	* 前置聲明函數或樣板有時會害得標頭檔開發者難以輕易變動其 API. 就像擴大形參類型，加個自帶默認參數的模板形參等等。
	* 前置聲明來自命名空間 ``std::`` 的 symbol 時，其行為未定義。
	* 僅僅為了能前置聲明而重構程式碼（比如用指針成員代替對像成員），後者會變慢且複雜起來。
	* 還沒有實踐證實前置聲明的優越性。

結論：

	* 函數：用 ``#include``.
	* 類樣板：優先用 ``#includes``.
	* 類：用前置聲明固然不錯，但小心點。若說不定，還是用 ``#includes`` 好了。
	* 千萬別為了避免 ``includes`` 而把數據成員改成指針。

至於什麼時候包含標頭檔，參見 :ref:`name-and-order-of-includes`。

.. _inline-functions:

1.4. 內聯函數
~~~~~~~~~~~~~~~~~~~~~~

.. tip::

    只有當函數只有 10 行甚至更少時才將其定義為內聯函數.

定義:

    當函數被聲明為內聯函數之後, 編譯器會將其內聯展開, 而不是按通常的函數調用機制進行調用.

優點:

    當函數體比較小的時候, 內聯該函數可以令目標程式碼更加高效. 對於存取函數以及其它函數體比較短, 性能關鍵的函數, 鼓勵使用內聯.

缺點:

    濫用內聯將導致程序變慢. 內聯可能使目標程式碼量或增或減, 這取決於內聯函數的大小. 內聯非常短小的存取函數通常會減少代碼大小, 但內聯一個相當大的函數將戲劇性的增加代碼大小. 現代處理器由於更好的利用了指令緩存, 小巧的代碼往往執行更快。

結論:

    一個較為合理的經驗準則是, 不要內聯超過 10 行的函數. 謹慎對待解構子, 解構函數往往比其表面看起來要更長, 因為有隱含的成員和基類析構函數被調用!

    另一個實用的經驗準則: 內聯那些包含循環或 ``switch`` 語句的函數常常是得不償失 (除非在大多數情況下, 這些循環或 ``switch`` 語句從不被執行).

    有些函數即使聲明為內聯的也不一定會被編譯器內聯, 這點很重要; 比如虛函數和遞歸函數就不會被正常內聯.  通常, 遞歸函數不應該聲明成內聯函數.（YuleFox 注: 遞歸調用堆棧的展開並不像循環那麼簡單, 比如遞歸層數在編譯時可能是未知的, 大多數編譯器都不支持內聯遞歸函數). 虛函數內聯的主要原因則是想把它的函數體放在類定義內, 為了圖個方便, 抑或是當作文檔描述其行為, 比如精短的存取函數.

1.5. 函數參數的順序
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. tip::

    定義函數時, 參數順序依次為: 輸入參數, 然後是輸出參數.

C/C++ 函數參數分為輸入參數, 輸出參數, 和輸入/輸出參數三種. 輸入參數一般傳值或傳 ``const`` 引用, 輸出參數或輸入/輸出參數則是非 ``const`` 指針. 對參數排序時, 將只輸入的參數放在所有輸出參數之前. 尤其是不要僅僅因為是新加的參數, 就把它放在最後; 即使是新加的只輸入參數也要放在輸出參數之前.

這條規則並不需要嚴格遵守. 輸入/輸出兩用參數 (通常是類/結構體變數) 把事情變得複雜, 為保持和相關函數的一致性, 你有時不得不有所變通.

.. _name-and-order-of-includes

1.6. ``#include`` 的路徑及順序
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. tip::
    使用標準的標頭檔包含順序可增強可讀性, 避免隱藏依賴: 相關標頭檔, C 庫, C++ 庫, 其他庫的 `.h`, 本專案內的 `.h`.

專案內標頭檔應按照項目源程式碼目錄樹結構排列, 避免使用 UNIX 特殊的快捷目錄 ``.`` (當前目錄) 或 ``..`` (上級目錄). 例如, ``google-awesome-project/src/base/logging.h`` 應該按如下方式包含:

    .. code-block:: c++

        #include 「base/logging.h」

又如, ``dir/foo.cc`` 的主要作用是實現或測試 ``dir2/foo2.h`` 的功能, ``foo.cc`` 中包含標頭檔的次序如下:

    #. ``dir2/foo2.h`` (優先位置, 詳情如下)
    #. C 系統文件
    #. C++ 系統文件
    #. 其他庫的 ``.h`` 文件
    #. 本專案內 ``.h`` 文件

這種排序方式可有效減少隱藏依賴. 我們希望每一個標頭檔都是可被獨立編譯的 (Yang.Y 譯注: 即該標頭檔本身已包含所有必要的顯式依賴), 最簡單的方法是將其作為第一個 ``.h`` 文件 ``#included`` 進對應的 ``.cc``.

``dir/foo.cc`` 和 ``dir2/foo2.h`` 通常位於同一目錄下 (如 ``base/basictypes_unittest.cc`` 和 ``base/basictypes.h``), 但也可以放在不同目錄下.

按字母順序對標頭檔包含進行二次排序是不錯的主意 (Yang.Y 譯注: 之前已經按標頭檔類別排過序了).

您所依賴的 symbols 被哪些標頭檔所定義，您就應該包含（include）哪些標頭檔，:ref:`forward-declaration` 情況除外。比如您要用到 ``bar.h`` 中的某個 symbol, 哪怕您所包含的 ``foo.h`` 已經包含了 ``bar.h``, 也照樣得包含 ``bar.h``, 除非 ``foo.h`` 有明確說明它會自動向您提供 ``bar.h`` 中的 symbol. 不過，凡是 cc 文件所對應的「相關頭文件」已經包含的，就不用再重複包含進其 cc 文件裡面了，就像 ``foo.cc`` 只包含 ``foo.h`` 就夠了，不用再管後者所包含的其它內容。

舉例來說, ``google-awesome-project/src/foo/internal/fooserver.cc`` 的包含次序如下:

	.. code-block:: c++

		#include "foo/public/fooserver.h" // 優先位置

		#include <sys/types.h>
		#include <unistd.h>
		#include <hash_map>
		#include <vector>

		#include "base/basictypes.h"
		#include "base/commandlineflags.h"
		#include "foo/public/bar.h"

例外：

有時，平台特定（system-specific）程式碼需要條件編譯（conditional includes），這些代碼可以放到其它 includes 之後。當然，您的平台特定代碼也要夠簡練且獨立，比如：

	.. code-block:: c++

		#include "foo/public/fooserver.h"

		#include "base/port.h"  // For LANG_CXX11.

		#ifdef LANG_CXX11
		#include <initializer_list>
		#endif  // LANG_CXX11

譯者 (YuleFox) 筆記
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#. 避免多重包含是學編程時最基本的要求;
#. 前置聲明是為了降低編譯依賴，防止修改一個標頭檔引發多米諾效應;
#. 內聯函數的合理使用可提高程式碼執行效率;
#. ``-inl.h`` 可提高程式碼可讀性 (一般用不到吧:D);
#. 標準化函數參數順序可以提高可讀性和易維護性 (對函數參數的堆棧空間有輕微影響, 我以前大多是相同類型放在一起);
#. 包含文件的名稱使用 ``.`` 和 ``..`` 雖然方便卻易混亂, 使用比較完整的專案路徑看上去很清晰, 很條理, 包含文件的次序除了美觀之外, 最重要的是可以減少隱藏依賴, 使每個標頭檔在 "最需要編譯" (對應源文件處 :D) 的地方編譯, 有人提出庫文件放在最後, 這樣出錯先是項目內的文件, 標頭檔都放在對應源文件的最前面, 這一點足以保證內部錯誤的及時發現了.

譯者（acgtyrant）筆記
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#. 原來還真有專案用 ``#includes`` 來插入文本，且其文件擴展名 ``.inc`` 看上去也很科學。
#. Google 已經不再提倡 ``-inl.h`` 用法。
#. 注意，前置聲明的類是不完全類型（incomplete type），我們只能定義指向該類型的指針或引用，或者聲明（但不能定義）以不完全類型作為參數或者返回類型的函數。畢竟編譯器不知道不完全類型的定義，我們不能創建其類的任何對象，也不能聲明成類內部的數據成員。
#. 類內部的函數一般會自動內聯。所以某函數一旦不需要內聯，其定義就不要再放在標頭檔裡，而是放到對應的 ``.cc`` 文件裡。這樣可以保持標頭檔的類相當精煉，也很好地貫徹了聲明與定義分離的原則。
#. 在 ``#include`` 中插入空行以分割相關標頭檔, C 庫, C++ 庫, 其他庫的 ``.h`` 和本專案內的 ``.h`` 是個好習慣。
